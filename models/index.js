// Generated by CoffeeScript 1.6.2
"use strict";
var AND, BND, BST, Branch, CTD, CTU, Counter, CounterTimer, END, EOR, Logical, NOT, NXB, OR, OSR, OTE, OTL, OTU, RES, RTO, SOR, TOF, TON, Timer, XIC, XIO, XOR, bitwiseInput, bitwiseOutput, branchClosing, branchInstruction, counterInstruction, counterTimerInstruction, db, ending, execute, functionMap, labObject, model, mongoose, problemObject, ready, rungObject, schema, timerInstruction, _ref, _ref1,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Array.prototype.find = function(findObject) {
  var element, found, isMatch, item, key, _i, _j, _len, _len1;

  found = [];
  for (_i = 0, _len = this.length; _i < _len; _i++) {
    item = this[_i];
    isMatch = true;
    for (key = _j = 0, _len1 = findObject.length; _j < _len1; key = ++_j) {
      element = findObject[key];
      if (item[key] !== element) {
        isMatch = false;
        break;
      }
    }
    if (isMatch) {
      found.push(item);
    }
  }
  return found;
};

Array.prototype.update = function(findObject, updateObject) {
  var indexToUpdate, objectsFound, objectsToUpdate;

  objectsFound = this.find(findObject);
  if (objectsFound.length !== 0) {
    objectsToUpdate = objectsFound[0];
    indexToUpdate = this.indexOf(objectToUpdate);
    this[indexToUpdate] = updateObject;
    return this[indexToUpdate];
  }
  return false;
};

mongoose = require("mongoose");

if (process.env.test) {
  mongoose.connect("mongodb://localhost/test");
} else {
  mongoose.connect("mongodb://" + process.env.MONGOLABS_USER + ":" + process.env.MONGOLABS_PASS + "@ds061787.mongolab.com:61787/heroku_app15454729");
}

model = mongoose.model;

schema = mongoose.Schema;

db = exports.db = mongoose.connection;

exports.labObject = labObject = {
  name: String,
  date: Date,
  uploadURL: String,
  problems: Array
};

exports.problemObject = problemObject = {
  name: String,
  rungs: Array,
  score: Number,
  lab: String
};

exports.rungObject = rungObject = {
  value: String,
  problem: String
};

exports.ready = ready = function(handler) {
  return db.once("open", handler);
};

SOR = function(matchValues, dataTable) {
  var matchText, rungNumber;

  matchText = matchValues[0], rungNumber = matchValues[1];
  dataTable.rungs = dataTable.rungs || [];
  dataTable.rungs.push(rungNumber);
  dataTable.activeRung = rungNumber;
  dataTable.rungOpen = true;
  dataTable.programOpen = true;
  return dataTable;
};

ending = function(lastAction, errorMessage) {
  if (errorMessage == null) {
    errorMessage = "EOR does not match SOR";
  }
  return function(matchValues, dataTable) {
    var matchText, rungNumber;

    matchText = matchValues[0], rungNumber = matchValues[1];
    if (rungNumber === dataTable.activeRung) {
      dataTable.rungOpen = false;
      if (typeof lastAction === "Function") {
        lastAction;
      }
      return dataTable;
    } else {
      throw "EOR does not match SOR";
    }
  };
};

EOR = ending;

END = ending(function() {
  return dataTable.programOpen = false;
}, "END does not match SOR");

bitwiseInput = function(bitwiseFunction) {
  return function(matchValues, dataTable) {
    var bit, file, matchText, rank;

    matchText = matchValues[0], file = matchValues[1], rank = matchValues[2], bit = matchValues[3];
    if (bitwiseFunction(dataTable[file][rank][bit])) {
      return dataTable;
    } else {
      return false;
    }
  };
};

XIC = bitwiseInput(function(bit) {
  return bit === true || bit === 1;
});

XIO = bitwiseInput(function(bit) {
  return bit === false || bit === 0;
});

bitwiseOutput = function(set, latchAction) {
  if (latchAction == null) {
    latchAction = function() {};
  }
  return function(matchValues, dataTable) {
    var bit, file, matchText, rank;

    matchText = matchValues[0], file = matchValues[1], rank = matchValues[2], bit = matchValues[3];
    dataTable[file] = dataTable[file] || {};
    dataTable[file][rank] = dataTable[file][rank] || {};
    dataTable[file][rank][bit] = set;
    return dataTable = latchAction;
  };
};

OTE = bitwiseOutput(true);

OTL = bitwiseOutput(true, function() {
  dataTable["latch"] = dataTable["latch"] || [];
  if (dataTable["latch"].indexOf({
    file: file,
    rank: rank,
    bit: bit
  } === -1)) {
    dataTable["latch"].push({
      file: file,
      rank: rank,
      bit: bit
    });
  }
  return dataTable;
});

OTU = bitwiseOutput(false, function() {
  var removeIndex;

  if (dataTable["latch"] != null) {
    removeIndex = dataTable["latch"].indexOf({
      file: file,
      rank: rank,
      bit: bit
    });
  }
  if (removeIndex !== -1) {
    dataTable.splice(removeIndex, 1);
  }
  return dataTable;
});

OSR = function(matchValues, dataTable) {
  var bit, file, findObject, foundOneShots, matchText, rank;

  matchText = matchValues[0], file = matchValues[1], rank = matchValues[2], bit = matchValues[3];
  if (dataTable[file][rank][bit]) {
    return false;
  } else {
    dataTable[file][rank][bit] = true;
    dataTable["oneShots"] = dataTable["oneShots"] || [];
    findObject = {
      file: file,
      rank: rank,
      bit: bit
    };
    foundOneShots = dataTable["oneShots"].find(findObject);
    if (foundOneShots.length === 0) {
      dataTable["oneShots"].push({
        file: file,
        rank: rank,
        bit: bit,
        active: true
      });
    } else {
      dataTable["oneShots"].update(findObject, {
        file: file,
        rank: rank,
        bit: bit,
        active: true
      });
    }
    return dataTable;
  }
};

branchInstruction = function(branchAction) {
  return function(matchValues, dataTable) {
    var branchNumber, matchText;

    matchText = matchValues[0], branchNumber = matchValues[1];
    return dataTable = branchAction;
  };
};

Branch = (function() {
  function Branch(branchNumber) {
    this.branchNumber = branchNumber;
    this.topLine = true;
    this.bottomLine = true;
    this.onTopLine = true;
    this.open = true;
  }

  return Branch;

})();

BST = branchInstruction(function() {
  dataTable.branches = dataTable.branches || [];
  dataTable.branches[branchNumber - 1] = new Branch(branchNumber);
  return dataTable;
});

branchClosing = function(closingType) {
  return branchInstruction(function() {
    var activeBranch, correctLine, thingToClose;

    activeBranch = dataTable.branches[branchNumber - 1];
    if (closingType === "NXB") {
      correctLine = activeBranch.onTopLine;
      thingToClose = "onTopLine";
    } else {
      correctLine = !activeBranch.onTopLine;
      thingToClose = "open";
    }
    if (correctLine) {
      if (activeBranch.open) {
        activeBranch[thingToClose] = false;
        dataTable.branches[branchNumber - 1] = activeBranch;
        return dataTable;
      } else {
        throw "Encountered " + closingType + " for closed branch";
      }
    } else {
      throw "Unexpected " + closingType;
    }
  });
};

NXB = branchClosing("NXB");

BND = branchClosing("BND");

Logical = function(bitwiseFunction) {
  return function(matchValues, dataTable) {
    var destFile, destRank, i, matchText, sourceAfile, sourceArank, sourceBfile, sourceBrank, _i, _len, _ref;

    matchText = matchValues[0], sourceAfile = matchValues[1], sourceArank = matchValues[2], sourceBfile = matchValues[3], sourceBrank = matchValues[4], destFile = matchValues[5], destRank = matchValues[6];
    dataTable[destFile] = dataTable[destFile] || {};
    dataTable[destFile][destRank] = dataTable[destFile][destRank] || {};
    _ref = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      i = _ref[_i];
      dataTable[sourceAfile][sourceArank][i] = dataTable[sourceAfile][sourceArank][i] || 0;
      dataTable[sourceBfile][sourceBrank][i] = dataTable[sourceBfile][sourceBrank][i] || 0;
      dataTable[destFile][destRank][i] = bitwiseFunction(dataTable[sourceAfile][sourceArank][i], dataTable[sourceBfile][sourceBrank][i]);
    }
    return dataTable;
  };
};

AND = Logical(function(a, b) {
  return a && b;
});

OR = Logical(function(a, b) {
  return a || b;
});

XOR = Logical(function(a, b) {
  return a ^ b;
});

NOT = Logical(function(a, b) {
  return !a;
});

CounterTimer = (function() {
  function CounterTimer(number, preset) {
    this.number = number;
    this.preset = preset;
    this.acc = 0;
    this.en = true;
    this.dn = this.done();
  }

  CounterTimer.prototype.tickUp = function() {
    this.acc++;
    return this.dn = this.done();
  };

  CounterTimer.prototype.tickDown = function() {
    this.acc--;
    return this.dn = this.done();
  };

  CounterTimer.prototype.done = function() {
    return this.acc >= this.preset;
  };

  return CounterTimer;

})();

Counter = (function(_super) {
  __extends(Counter, _super);

  function Counter() {
    _ref = Counter.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  Counter.prototype.CU = function() {
    this.tickUp();
    return this.cu = true;
  };

  Counter.prototype.CD = function() {
    this.tickDown();
    return this.cu = true;
  };

  Counter.prototype.OV = function() {};

  Counter.prototype.UV = function() {};

  return Counter;

})(CounterTimer);

Timer = (function(_super) {
  __extends(Timer, _super);

  function Timer() {
    _ref1 = Timer.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  Timer.prototype.tick = function() {
    if (!this.done()) {
      this.tickUp();
      return this.tt = true;
    } else {
      return this.tt = false;
    }
  };

  return Timer;

})(CounterTimer);

counterTimerInstruction = function(file, action) {
  return function(matchValues, dataTable) {
    var number, preset, unit;

    number = matchValues[0], preset = matchValues[1];
    dataTable[file] = dataTable[file] || {};
    dataTable[file][number] = dataTable[file][number] || new CounterTimer(number, preset);
    unit = dataTable[file][number];
    return dataTable = action(unit);
  };
};

timerInstruction = function(timerAction) {
  return counterTimerInstruction("T4", timerAction);
};

TON = timerInstruction(function(timer) {});

TOF = timerInstruction(function(timer) {});

RTO = timerInstruction(function(timer) {});

RES = function(matchValues, dataTable) {
  var file, matchText, rank;

  matchText = matchValues[0], file = matchValues[1], rank = matchValues[2];
  return dataTable[file][rank].acc = 0;
};

counterInstruction = function(counterAction) {
  return counterTimerInstruction("C5", counterAction);
};

CTU = counterInstruction(function(counter) {});

CTD = counterInstruction(function(counter) {});

functionMap = {
  "SOR,(\\d+)": SOR,
  "EOR,(\\d+)": EOR,
  "END,(\\d+)": END,
  "XIC,(\\w+):(\\d+)\\/(\\d{1,2})": XIC,
  "XIO,(\\w+):(\\d+)\\/(\\d{1,2})": XIO,
  "OTE,(\\w+):(\\d+)\\/(\\d{1,2})": OTE,
  "OTL,(\\w+):(\\d+)\\/(\\d{1,2})": OTL,
  "OTU,(\\w+):(\\d+)\\/(\\d{1,2})": OTU,
  "OSR,(\\w+):(\\d+)\\/(\\d{1,2})": OSR,
  "BST,(\\d+)": BST,
  "NXB,(\\d+)": NXB,
  "BND,(\\d+)": BND,
  "AND,(\\w+):(\\d+),(\\w+):(\\d+),(\\w+):(\\d+)": AND,
  "OR,(\\w+):(\\d+),(\\w+):(\\d+),(\\w+):(\\d+)": OR,
  "XOR,(\\w+):(\\d+),(\\w+):(\\d+),(\\w+):(\\d+)": XOR,
  "NOT,(\\w+):(\\d+),(\\w+):(\\d+)": NOT,
  "TON,T4:(\\d+),(\\d+)": TON,
  "TOF,T4:(\\d+),(\\d+)": TOF,
  "RTO,T4:(\\d+),(\\d+)": RTO,
  "RES,(\\w+):(\\d+)": RES,
  "CTU,C5:(\\d+),(\\d+)": CTU,
  "CTD,C5:(\\d+),(\\d+)": CTD
};

execute = function(instruction, dataTable) {
  var f, matchValues, re;

  for (re in functionMap) {
    f = functionMap[re];
    matchValues = instruction.match(new RegExp(re));
    if (matchValues != null) {
      dataTable = f(matchValues, dataTable);
    }
  }
  return dataTable;
};

ready(function() {
  var Lab, Problem, Rung;

  Lab = exports.Lab = mongoose.model("Lab", mongoose.Schema(labObject));
  Problem = exports.Problem = mongoose.model("Problem", mongoose.Schema(problemObject));
  Rung = exports.Rung = mongoose.model("Rung", mongoose.Schema(rungObject));
  return Rung.prototype.run = function(inputObject) {
    var instruction, instructions, item, outputObject, result, _i, _j, _len, _len1;

    outputObject = {};
    for (_i = 0, _len = inputObject.length; _i < _len; _i++) {
      item = inputObject[_i];
      outputObject[item] = inputObject[item];
    }
    instructions = value.split(" ");
    for (_j = 0, _len1 = instructions.length; _j < _len1; _j++) {
      instruction = instructions[_j];
      result = execute(instruction, outputObject);
      if (result != null) {
        outputObject = result;
      } else {
        break;
      }
    }
    return outputObject;
  };
});
